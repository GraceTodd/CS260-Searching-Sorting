<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Grace Todd</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <!-- Custom styles for this template -->
    <link href="FIXME.css" rel="stylesheet">
  </head>

  <body>

    
    
    
    <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
      <a class="navbar-brand" href="#">Navbar</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <ul class="navbar-nav mr-auto">
          <li class="nav-item active">
            <a class="nav-link" href="https://gracetodd.github.io/">Home <span class="sr-only">(current)</span></a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://gracetodd.github.io/CS161/">CS161</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://gracetodd.github.io/CS162/">CS162</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="http://example.com" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CS260</a>
            <div class="dropdown-menu" aria-labelledby="dropdown01">
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Recursion/">Recursion</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Unit-Testing/">Unit Testing</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Searching-Sorting/">Searching and Sorting</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Dynamic-Programming/">Dynamic Programming</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Closures/">Closures</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Tree-Algorithms/">Tree Algorithms</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Graph-Algorithms/">Graph Algorithms</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-ADT/">ADT:</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Stack-ADT/">Stack</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-List-ADT/">List</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Queue-ADT/">Queue</a>
              <a class="dropdown-item" href="https://gracetodd.github.io/CS260-Dequeue-ADT/">Dequeue</a>
            </div>
          </li>
        </ul>
        <form class="form-inline my-2 my-lg-0">
          <input class="form-control mr-sm-2" type="text" placeholder="Search" aria-label="Search">
          <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
        </form>
      </div>
    </nav>

    
    
    
    
    
    
    <main role="main">

      <!-- Main jumbotron for a primary marketing message or call to action -->
      <div class="jumbotron">
        <div class="container">
          <h1 class="display-3">Searching And Sorting</h1>
          
          
          <h2>Searching</h2>
          <p>Searching is the algorithmic process of finding a particular item in a collection of items.
          A search typically answers either TRUE or FALSE as to whether the item is present. On occasion
          it can be modified to return whether the item is FOUND.</p>
          <p>In Python, there is a simple way to ask whether an item is in a list of items: using the IN operator.</p>
          <p>>>> 15 in [3, 4, 2, 4, 1]</p>
          <p>False</p>
          <p> However, there are other, more explicitly stated functions that can be implemented into a Python 
          program specifically. For instance, the Sequential Search. </p>
          
          <h3>The Sequential Search</h3>
          <p>When data items are stored in a collection such as a list, we say that they have a linear or sequential 
          relationship. Each data item is stored in a position relative to the others. In Python lists, these relative positions are the index values
          of the individual items. Since these index values are ordered, it is possible for us to visit them in sequence.
          This process gives rise to our first searching technique, the sequential search.</p>
          <p>If the item is present within the list, the complexity of the sequential search is O(1) at best and O(n)
          at worst. If the item is not present, the complexity will only be O(n).</p>
          
          <iframe src="https://pastebin.com/embed_iframe/rubiunw5" style="border:none;width:100%;height:500px"></iframe>
          
          <p>Because the function orderedSequentialSearch searches an ordered list, we can use the other values in the list to 
          decide whether or not we have passed where the value should be. For instance, if we are searching for the value
          5 but our sequential search function has found the value 7, our function can postulate that the list does not
          hold a value of 5.</p>
          
          <h3>The Binary Search</h3>
          <p>It is possible to take greater advantage of the ordered list if we are clever with our comparisons.
          In the sequential search, when we compare against the first item, there are at most n - 1 more items 
          to look through if the first item is not what we are looking for. Instead of searching a list in 
          sequence, a BINARY SEARCH will start by examining the middle term. I fthat item is the one we are
          searching for, we are done. If it is not the correct item, we can use the ordered nature of the list 
          to eliminate half of the remaining items. If the item we are searching for is greater than the middle 
          item, we know that the entire lower half of the list as well as the middle item can be eliminated from 
          further consideration.</p>
          
          <p>One of the drawbacks of a binary search is that because it searches directly based on whether or not
          the selected term is greater than or less than the sought out item, it cannot be done on an unordered list.
          If we start with a sorted list of n items, about (n/2) items will be left after the first comparison. After
          the second comparison, there will be about (n/4), then (n/8), and so on. The maximum number of comparisons 
          is logarithmic with respect to the number of items in the list. Therefore teh binary search is O(log n).
          For this reason, it is important to note that for small values of n, the additional cost of sorting is
          probably not worth it, even though a binary search is generally better than a sequential search. Even for 
          large lists, however, sorting even once can be so expensive that simply performing a sequential search
          from the start may be the best choice. </p>
          
          <p>Here is an example of two ways to implement teh binary search in Python, both iteratively and 
            recursively:</p>
          
          <iframe src="https://pastebin.com/embed_iframe/xEx1WYQM" style="border:none;width:100%;height:1000px"></iframe>
          
          <h3>Hashing</h3>
          <p>Hashing is a data structure that can be searched in O(1) time. In order to do this, we will need to 
            know even more about where the items might be when we go to look for them in the collection. If every 
            item is where it should be, then the search can use a single comparison to discover the presence of 
            an item. However, this is not typically the case. </p>
            
          <p>With hashing, you do not need to actually search to get a result. Hashing is done by creating a hash 
            table, which contains slots that each hold an item that is names by an integer value. For example, we will
            have a slot named 0, a slot named 1, a slot named 2, and so on.</p>
          
          <p>We can implement a hash table in Python by using a list with each element initialized to the special 
            Python value NONE. The mappign between an item and the slot where that item belongs in the hash table 
            is called the hash function. The hash function will take any item in the collection and return an 
            integer in the range of slot name, between 0 and (m - 1). Our first hash function, sometimes referred
            to as the "Remainder Moethod," simply takes an item and divides it by the table size, returning the 
            remainder as its hash value. (h(item) = item % 11). Once the hash values have been computed, we can
          insert each item into the hash table at the designated position. This is referred to as the load factor, 
            and is commonly denotes by [lamda] = (numberofitems)/(tablesize).</p>
          
          <p>When we want to search fro an item, we simply use the hash function to compute the slot name for the 
            item and then check the hash table to see if it is present. Hashing is a data structure that can search 
            in O(1) time, since a constant amount of time is required to compute the hash value and then index the 
            hash table at that location.</p>
          
          <p>Here is a great video that elaborates on the usefulness of Hash Tables:</p>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/shs0KM3wKv8" 
                  frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
          <p>     </p>
          <p>     </p>
          <p>     </p>
          <h3>Implementing Hash Tables in Python</h3>
          <p>Here is some sample hashing code created in the CS260: Data Structures class at COCC. The first sectioon of code is the 
          Node class, which allows us to navigate and search the hash table using variables "key" and "value."</p>
          <iframe src="https://pastebin.com/embed_iframe/6A0RWGm3" style="border:none;width:100%"></iframe>
          
          <p>This file is then implemented into our HashMap class:</p>
          <iframe src="https://pastebin.com/embed_iframe/DisptVRP" style="border:none;width:100%"></iframe>
          <p>The lines of code underneath the HASHMAP class are a brief test to check if our functions run.</p>
          
          
          <!-- <p><a class="btn btn-primary btn-lg" href="#" role="button">Learn more &raquo;</a></p> -->
            
          <h2>Sorting</h2>
          <p>Sorting is the process of placing elements from a collection in some kind of order. For example, 
            a list of words could be sorted alphabetically or by length. A list of cities could be sorted by 
            population, by area, or by zip code. We have already seen a number of algroithms that were able 
            to benefit from having a sorted list.</p>
          <p>There are many, many sorting algorithms that have been developed and analyzed. This suggests that
            sorting is an important area of study in computer science. Sorting a large number of items can take
            a substantial amount of computing resources. Like searching, the efficiency of a sorting algorithm 
            is related to the number of items being processed. For small collection, a complex sorting method 
            may be more trouble than it is worth. The overhead may be too high. On the other hand, for larger 
            collections, we want to take advantage of as many improvements as possible. </p>
          <h3>The Bubble Sort</h3>
          <p> The bubble sort makes multiple passes through a list. It copares adjacent items and exchanges 
            those that are out of order. Each pass through the list places the next largest value in its 
            proper place. In essence, each item "bubbles" up to the location where it belongs, hence the name.</p>
          
          <iframe width="560" height="315" src="https://www.youtube.com/embed/kPRA0W1kECg" frameborder="0" 
          allow="autoplay; encrypted-media" allowfullscreen></iframe>
            
        </div>
      </div>
        <hr>

      </div> <!-- /container -->
      
    </main>

    <footer class="container">
      <p>&copy; Grace Todd 2017-2018</p>
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster nice -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
